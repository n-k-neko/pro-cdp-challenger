## 概要
- フロントエンドでReactを学びたく、バックエンドでは**WebAPI**を提供する。
- クリーンアーキテクチャの原則を取り入れつつ、ヘキサゴナルアーキテクチャをベースとする。
- オブジェクトは、データの入れ物ではなく機能を有する部品として設計する。
---

## アーキテクチャ（オンライン）
クリーンアーキテクチャの原則を取り入れつつ、ヘキサゴナルアーキテクチャをベースに構築する。
### ヘキサゴナルアーキテクチャ
構成例は以下。
```plaintext
src
├── adapter
│   ├── inbound
│   │   ├── controller
│   │   │   └── UserRegistraitonController.java
│   │   ├── security
│   │   │   └── SecurityConfig.java
│   └── outbound
│       ├── repository
│       │   └── UserRegistraitonRepositoryImpl.java
├── application
│   ├── port
│   │   ├── inbound
│   │   │   └── UserRegistraitonUseCase.java
│   │   └── outbound
│   │       └── UserRegistraitonRepository.java
│   ├── service
│   │   └── UserRegistraitonService.java
│   ├── rule
│   │   └── UserRegistraitonRule.java
│   └── policy
│       └── UserRegistraitonPolicy.java
├── domain
│   ├── entity
│   │   └── UserForRegistraiton.java
│   ├── valueobject
│   │   └── UserId.java
│   ├── service
│   │   └── FeeCalculationService.java
│   ├── rule
│   │   └── UserRule.java
│   └── policy
│       └── UserPolicy.java
└── infrastructure
    ├── security
    └── api
        └── RestApiClient.java
```
### 詳細
#### adapter層
- **inbound**: 外部からの入力を受け取り、受信ポートを呼び出す。
  - **例**: HTTPリクエストを処理する`Controller`。
  - **例**: Securityルールを定義する`SecurityConfig`。ただし、技術要素は**infrastructure層**に配置。
- **outbound**: 送信ポートを実装し、外部への出力を行う。
  - **例**: データベース操作を行う`Repository`実装。

#### application層
- **port**: アプリケーションと外部を抽象化するインタフェースを提供。
  - **inbound**: ユースケースを定義する受信ポート（例：`UserRegistraitonUseCase`）。
  - **outbound**: 永続化や外部サービス連携を抽象化する送信ポート（例：`UserRegistrationRepository`）。
- **service**: ユースケースを実装するサービスクラスを格納（例：`UserRegistrationService`）。
- **rule**: 外部制約に基づく業務ルールを表現（例：ユーザーID重複不可）。
- **policy**: 業務ルールの集合。

#### domain層
- **entity**: ドメインオブジェクトを格納（例：`UserForRegistration`）。
- **valueobject**: 値オブジェクトを格納（例：`UserId`）。
- **service**: ドメインロジックを提供（例：料金計算サービス）。
- **rule**: ドメインに特化したルールを表現（例：商品割引ルール）。
- **policy**: ドメインルールを組み合わせた判断基準（例：配送ポリシー）。

#### infrastructure層
- **技術的な要素を実装する。**
  - **例**: トークン操作などSecurityの技術的部分、外部APIクライアント。

## クラウド
- AWSを利用する。
- 利用サービス予定。
    - ECS：オンラインAP、バッチAP
    - S3：ログ保管、バックアップ保管、オンライン業務で何らかの利用機能（←作る）
    - SQS：バッチAP to バッチAP
    - Elastic Cache：資格リコメンド情報
    - DynamoDB：資格一覧

## 実装
### クラス・レコード・オブジェクト
- オブジェクトは原則イミュータブルとする。そのため、**Setter**を原則設けない。
- オブジェクトのイミュータブルをJavaの機能で実現するために**record**を積極的に用いる。  
    ただし以下の場合はクラスとする。
    - DIコンテナに登録されたクラスをフィールドに有する場合
    - 継承またはインタフェース実装を行う場合
    - 不変にできないフィールドを有する場合
- 各種値は、値オブジェクトとして、クラスまたはレコードで表現する。
- オブジェクトをデータの入れ物として用いるのではなく、オブジェクト自体に機能（メソッド）を具備する。
- 継承は極力控える。インタフェースやフィールドオブジェクトで代替する。
- クラスへのLombokアノテーションの付与は許容する。O/Rマッパーについては後述。

### ルール、ポリシー
- ポリシーはルールの集合とする。
- ユースケースの実装クラスでif文などを大量に用いてチェックを行うのではなく、各ルールをそれぞれクラスで表現し、ポリシークラスで各ルールクラスとの関係をチェックする。
- ルールおよびポリシーは、ドメイン層とアプリケーション層でそれぞれ設ける。チェックする内容が違うため。
    - ドメイン層：純粋なドメイン個別固有の制約
    - アプリケーション層：外部制約

### リポジトリーとデータベース
- ドメインごとにHogeRepositoryという形にするのではなく、ドメイン内でも用途に応じてRepositoryを分割する。つまり、**UserRepository**などを作ってしまい、Repositoryが肥大化、責任が集中することを避ける。
    - ただし、汎用的な処理を**UserRepository**としてまとめることは許容する。
- RDMSにおいては、原則オプティマイザーを信用し、ヒント句の使用は控える。問題が生じたときのみヒント句の使用を検討する。
- O/Rマッパーを導入する場合は、ドメインのエンティティに付与するのではなく、専用のクラスを用意してドメインのエンティティクラスをマッピングする。つまり、ドメインのエンティティにはO/Rマッパーは持ち込まない。
- レコードにNULLを認めるか否か、イベントをすべて記録するかどうか、レコードのUPDATEを禁止してINSERTとDELETEのみでデータベースを操作するかどうか、などは今後検討する。

### 条件分岐
- ネスト構造は極力避ける。早期returnなどで対応する。
- switchやifでの区分分岐は修正の際の抜け洩れが怖いので、デザインパターンでの実装を検討する。
### 計算量
- 時間計算量が劇的に削減できない限りは、複雑なアルゴリズムは控える。劇的に削減の基準はオーダー記法でのNの次数が下がる場合を指す。
    - 友達機能を実装した場合などに時間計算量を意識する可能性が出てくるかもしれない。「2ノード以内の友人の取得/学習している資格一覧を取得しレコメンド」など。幅優先探索をしてプライオリティキューで順位付けするだけなので問題ないのでは。
    - 入力補助を入れる場合はトライ木なので、これが本命？

### 例外
- 異常系は例外をスローしてハンドリングする。
- 例外ハンドリングは **@ControllerAdvice** を用いてグローバル例外ハンドラーを実装する。
- カスタム例外を作りすぎると保守が大変になるため、汎用的な例外と少しの例外だけを用意し、メッセージを細分化することで対応する。

### ロギング
- LF4JとLogbackを使ってログを記録する。
- ログレベルの設定と運用については今後検討する。
    - ファイル出力やログ運用（S3）など

### 試験
- 最終的にはE2Eまでを目指したい。
- 単体、結合、システム試験の割合はピラミッド型になるようにする。
- 複合性能試験も最終的にはやってみたい。

### リフレクション
- **闇魔術**なので使わない。が、どこかで学習したい。
    - カスタムバリデーションアノテーションでは使用するかもしれない
