# ソフトウェアアーキテクチャ

## 概要

---
## アーキテクチャスタイル
クリーンアーキテクチャの原則を取り入れつつ、ヘキサゴナルアーキテクチャをベースに構築する。
### ヘキサゴナルアーキテクチャ
前提：[旬なアーキテクチャって何だろう？（SOMPOシステムズ）](https://note.sompo-sys.com/n/n62fdd17a7dc4#03829441-0b62-48aa-b642-775854bb8a1b)   
詳細：[Hexagonal Architecture(ヘキサゴナルアーキテクチャ) とは]([text](https:/zenn.dev/heyyou/articles/f380adb8d1fe8f))
### 選定理由
- **伝統的な3層構造を避けた理由**
  - サービス層がリポジトリ層に直接依存することで、リポジトリの変更がサービス層全体に影響を及ぼす可能性がある。
  - **インタフェース**を用いて**依存性逆転の原則**を適用することで依存関係を逆転させることは可能だが、データアクセス層を最下層に置くという固定観念が原則適用の妨げになることがある。
  - 3層構造ではサービス層が肥大化しやすい
    - ドメイン層：業務ルールなど対象オブジェクトを実現する層。ドメインのコアを表現。
    - アプリケーション層：ドメインのサブ層。
      - ユースケースを実現
      - 外部制約との整合性の確認
- **アーキテクチャ設計の目標**
  - インフラストラクチャを外側に配置し、アプリケーション／ドメイン層がデータアクセスやインフラストラクチャに依存しない構造を目指す。
    - ドメイン層を中心とした設計を採用することで、ドメインのコアがユースケースやインフラストラクチャの詳細に依存しない形で実装できる。
  - これにより、システムの柔軟性と保守性が向上し、ビジネス要件の変更に迅速に対応可能となる。
- **ヘキサゴナルアーキテクチャの特徴**
  - **クリーンアーキテクチャ**や**オニオンアーキテクチャ**でも同様の目的は達成可能だが、ヘキサゴナルアーキテクチャは、**アダプター**や**ポート**といった役割を明示的に定義している点が特徴的。
  - **ポート**や**アダプター**と明確に分離することで、インフラストラクチャがアプリケーションロジックに影響を与えない設計が可能。
    - データアクセス層は、 **アダプター（アウトバウンド）** として配置され、インフラ層とは分離される。インフラ層はアプリケーションの技術的な部分を担っており、より厳密な分担となっている。
  - この明確な役割分担により、実装者間で統一したパッケージ構成を自然に選択でき、**実装の整合性を高める**効果がある。

### デメリット
- 役割によるパッケージの細分化となるため、アクセス修飾子によるクラスの利用制限の設定が限定的となる
  - ドメインごとに様々な機能を同一パッケージに格納することで実現できるアクセス修飾子の効果とヘキサゴナルアーキテクチャのもたらす利点を天秤にかけて、許容できると判断。
- 伝統的な3層構造と比較してパッケージ構造の複雑性が高い
  - パッケージごとに役割を細分化されているため、見た目ほど複雑性は高くない。またパッケージによって関心の分離が実現されているため、保守性および可読性は向上している。許容できると判断。


### パッケージ構成
構成例は以下。
```plaintext
src
├── shared
│   ├── exception
│   │   ├── Base.java
│   │   └── ErrorCodes.java
├── adapter
│   ├── inbound
│   │   ├── controller
│   │   ├── dto
│   │   ├── security
│   │   │   └── SecurityConfig.java
│   │   ├── handler
│   │       └── GlobalExceptionHandler.java
│   └── outbound
│       ├── repository
│       │   └── UserRegistraitonRepositoryImpl.java
│       ├── webclient
│       │   └── WebClientAdapter.java
├── application
│   ├── port
│   │   ├── inbound
│   │   │   └── UserRegistraitonUseCase.java
│   │   └── outbound
│   │       ├── UserRegistraitonRepository.java
│   │       └── WebClientPort.java
│   ├── service
│   ├── rule
│   ├── policy
│   └── exception
├── domain
│   ├── entity
│   ├── valueobject
│   ├── service
│   ├── rule
│   ├── policy
│   └── exception
└── infrastructure
    ├── exception
    ├── security
    └── webclient
```
### パッケージ詳細
#### shared層
- **横断的な関心事**を格納する。
  - 例：基底例外クラス

#### adapter層
- **inbound**: 外部からの入力を受け取り、受信ポートを呼び出す。
  - **例**: HTTPリクエストを処理する`Controller`。
  - **例**: Securityルールを定義する`SecurityConfig`。ただし、技術要素は**infrastructure層**に配置。
- **outbound**: 送信ポートを実装し、能動的な外部通信を行う。
  - **例**: データベース操作を行う`Repository`実装（例：`UserRegistrationRepositoryImpl`）。
  - **例**: 外部サービスのWebAPIを発行する**Webクライアント**実装（例：`WebClientAdapter`）。

#### application層
- **port**: アプリケーションと外部を抽象化するインタフェースを提供。
  - **inbound**: ユースケースを定義する受信ポート（例：`UserRegistraitonUseCase`）。
  - **outbound**: 永続化や外部サービス連携を抽象化する送信ポート（例：`UserRegistrationRepository`）。
- **service**: ユースケースを実装するサービスクラスを格納（例：`UserRegistrationService`）。
- **rule**: 外部制約に基づく業務ルールを表現（例：ユーザーID重複不可）。
- **policy**: 業務ルールの集合。

#### domain層
- **entity**: ドメインオブジェクトを格納（例：`UserForRegistration`）。
- **valueobject**: 値オブジェクトを格納（例：`UserId`）。
- **service**: ドメインロジックを提供（例：料金計算サービス）。
- **rule**: ドメインに特化したルールを表現（例：商品割引ルール）。
- **policy**: ドメインルールの集合。

#### infrastructure層
- **技術的な関心事を格納する。**
  - **例**: トークン操作など、Securityの技術的部分
  - **例**: WebClientのBean定義

---
## 開発言語
**Java 23**+**Spring Boot**で開発する。理由は以下。
- 本アプリケーションの目的の一つが、AWS上で稼働し、AWSのサービスを積極的に利用し、他ウェブサービスとも連動する**現代的アプリケーションの理解**であるため、ある程度経験のある言語及びフレームワークを利用し、言語やフレームワークの学習コストを下げる。
    - JavaおよびSpring Bootは世界中で使われており、実績と資料が充実している。
    - 機能・パフォーマンス・セキュリティ・後方互換性・言語仕様バグ対応速度などの多角的な観点で優れている。
- Javaは**AWS SDK**でサポートされたプログラミング言語であり、AWSとの統合が比較的容易。
- 超高速なレスポンスが必要なサービスでもなく、膨大な計算量を必要とするサービスでもなく、GCによるアプリケーションの一時停止も許容できるサービスであるため、Javaのスペックで十分。
- JavaとSpringBootは、実業務で今後も継続的に使用する可能性が高く、**技術の実験場**として、ある程度の規模のSpringBootアプリケーションを用意する。
---
