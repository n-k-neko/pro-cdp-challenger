# 目次
- [概要](#概要)
- [クラウド](#クラウド)
- [実装](#実装)
  - [クラス・レコード・オブジェクト](#クラスレコードオブジェクト)
  - [ルールとポリシー](#ルールとポリシー)
  - [リポジトリーとデータベース](#リポジトリーとデータベース)
  - [条件分岐](#条件分岐)
  - [計算量](#計算量)
  - [例外設計方針と実装](#例外設計方針と実装)
  - [ロギング設計](#ロギング設計)
  - [Webクライアント](#Webクライアント)
- [試験](#試験)
  - [方針](#方針)
  - [具体的な記述](#具体的な記述)

# 概要
- **ファイルが肥大化したため、ファイルを分割中**。ソフトウェアアーキテクチャおよびセキュリティについては、[此方](/documents/development/)を参照。他の項目についても今後分割し、本ファイルは目次とする想定。
- フロントエンドでReactを学びたく、バックエンドでは**WebAPI**のみを提供する。
- クリーンアーキテクチャの原則を取り入れつつ、ヘキサゴナルアーキテクチャをベースとする。
- オブジェクトは、データの入れ物ではなく機能を有する部品として設計する。
---

# クラウド(TODO：今後別ファイルで切り出す。アプリからクラウド利用の方針のみを記載する。)
- AWSを利用する。
- 利用サービス予定。
    - ECS：オンラインAP、バッチAP
    - S3：ログ保管、バックアップ保管、オンライン業務で何らかの利用機能（←作る）
    - SQS：バッチAP to バッチAP
    - Elastic Cache：資格リコメンド情報
    - DynamoDB：資格一覧
---
# 実装
---
## クラス・レコード・オブジェクト
- 可読性および保守性の観点から、オブジェクトは原則イミュータブルとする。そのため、**Setter**は禁止。
  - オブジェクトの値を変更する場合は新たにオブジェクトを生成して返す。
    ```java
    public SomeObj add(SomeObj obj){
        return new SomeObj(this.value() + obj.value());
    } 
    ```
  - メモリ使用率, CPU負荷, GC頻度は上昇するが、昨今のハードおよびソフトの性能向上を鑑みて問題ないと判断。ただし、リソース状況は定期的に確認し、必要に応じてスケールアウトする。
- オブジェクトのイミュータブルをJavaの機能として実現するために、`Java SE 16`から正式導入された**レコード**を積極的に用いる。  
    - ただし以下の場合はクラスとする。
      - DIコンテナに登録されたBeanをフィールドに有する場合
      - 継承またはインタフェースの実装を行う場合
      - 不変にできないフィールドを有する場合
- ドメイン中で用いられる広義の**値**は、**クラスまたはレコード**で表現し、**値オブジェクト**として扱う。
  - 例：ユーザーID, メールアドレス, 金額, カード番号
  - 値オブジェクトを採用する利点の一例
    - 定義上不適切な値の混入を防止（コンストラクタによるガード節）
    - コードが分かりやすく安全（引数に値オブジェクト型を指定することで誤混入防止など）
    - 値の定義自体を値オブジェクトに閉じ込めやすくなる（`public static final int MAX_LENGTH = 100;`など）
    - 業務ロジックを値オブジェクトに閉じ込めやすくなる（加算など） 
- 値オブジェクトやドメインエンティティは、データの入れ物として用いるのではなく、機能を具備する。
- 継承は原則使用しない。インタフェースやフィールドオブジェクトで代替する。
  - 可読性が低下するため。
  - ビジネスにおいて継承関係は変化しやすい。継承関係をコードに持ち込むとビジネスの変化に伴って大規模なリファクタリングが必要になる可能性がありうる。
  - ただし、インフラストラクチャ層またはアダプター層において、フレームワークやライブラリを利用する場合は、継承を許容する。
- ドメインエンティティおよび値オブジェクトをライブラリやフレームワークに非依存の設計とする。
  - `Lombok`は例外として利用可とする。
  - `O/Rマッパー`を使用したい場合は専用のクラスを用意する。
---
## ルールとポリシー

### 基本概念
- **ルール**: 制約を表現するクラス。
- **ポリシー**: 複数のルールを組み合わせて、特定の目的に基づいた判断や検証を行うクラス。

### 設計指針
1. **ポリシーはルールの集合とする**:
   - ポリシークラスは、1つ以上のルールクラスをフィールドとして持ち、全体の検証ロジックを管理する。
   - 各ルールクラスは、独立した単位で単一責任の原則（SRP）を守る。
   - ルールクラスは、検証に失敗した場合に例外をスローする責務を持つ。これにより、異常系の処理をルール内部に閉じ込めることができる。
   - 一方で、複数のルールを複雑に組み合わせる（例: OR / NOT 条件）場合には、戻り値が`boolean`型のルールを活用する設計も検討する。
        - 例えば、ルールクラスで例外をスローする上記の設計では、少なくとも1つのルールを満たせば良い場合でも1つのルールで例外がスローされた時点で処理が終了してしまうため。
        - `boolean`型のルールを利用することで、ポリシークラス内でルールの組み合わせを柔軟に実現できる。
            - **例**: OR条件をポリシークラスで実現する場合。
                ```java
                public boolean anySatisfiedBy(T target) {
                    return rules.stream().anyMatch(rule -> rule.isSatisfiedBy(target));
                }
                ```

2. **ユースケース内でのチェックロジックの簡素化**:
   - ユースケース実装クラスで条件分岐を大量に用いるのではなく、各ルールをクラス化し、ポリシーでそれらの検証を統合する。
   - ポリシーを利用することで、読みやすく拡張性の高いコードを実現する。
     - ルール追加の際は新規ルールクラスの作成だけで追加を実現可能。既存コードは影響を受けない。
   - ポリシーは、ルールの`validate`メソッドを順次実行し、ルール内でスローされた例外をそのまま上位に伝播させる。

3. **ルールとポリシーの分離**:
   - ルールクラスは、個別の検証ロジックを担当し、ポリシークラスはそれらの組み合わせと実行の調整を行う。
   - ポリシーにおいてルールの組み合わせ（AND/OR/NOT）を柔軟に扱えるように設計する。

### 層ごとの適用
- **ドメイン層**:
  - 純粋なドメインモデル固有の制約をチェックする。
  - 例: 値オブジェクトやエンティティの状態に基づく検証。
  - ただし、単独で確認可能なチェック（不適切な値の混入など）については、値オブジェクトのコンストラクタによってチェックする。
- **アプリケーション層**:
  - 外部システムやユーザーインターフェースとのやり取りによる制約をチェックする。
  - 例: リクエストデータの整合性確認、IDの一意性、外部サービスとの依存関係に基づく条件。

### 実装例
#### ルールインターフェース
```java
public interface Rule<T> {
    // AND条件ではvoid型（異常系は例外をスロー）、OR条件であればboolean型
    void validate(T target); 
}
```
#### サンプルルール（ドメイン層）
```java
public class DateRangeRule implements Rule<SomeDomainObject> {
    @Override
    public void validate(SomeDomainObject target) {
        if (target.getDate().isAfter(LocalDate.now())) {
            throw new IllegalArgumentException("Date is out of range");
        }
    }
}
```
#### ポリシークラス
```java
public class Policy<T> {
    private final List<Rule<T>> rules;

    public Policy(List<Rule<T>> rules) {
        this.rules = rules;
    }

    public void validate(T target) {
        for (Rule<T> rule : rules) {
            rule.validate(target); // ルール内で例外をスロー
        }
    }
}
```
#### ユースケースの利用例（アプリケーション層）
```java
public class SomeService implments SomeUseCase {
    private final Policy<SomeDomainObject> policy;

    public SomeService(Policy<SomeDomainObject> policy) {
        this.policy = policy;
    }

    public void execute(SomeDomainObject object) {
        policy.validate(object); // 異常系の場合は例外をスローして処理終了
        
        // 検証に成功した場合の処理
    }
}
```
### 推奨
1. ルールを小さな単位に分割して再利用性を高める。
2. ルール同士を組み合わせるロジックをポリシークラスに委譲する。
3. ルールやポリシーのテストを個別に作成し、ユニットテストを通じて品質を保証する。

### 注意点
- ポリシーに含めるルールの粒度が大きくなりすぎないよう注意する。
- 各層で必要な検証ロジックを適切に分離し、責務の分散を図る。

---

## リポジトリーとデータベース
- コア/サブドメインごとに単一テーブルを設けるのではなく、用途に応じてテーブルを分割する。
- 上記に伴い、`Repository`も用途ごとに用意する。
  - 汎用的な情報および処理を集約するドメイン名のテーブルおよび`Repository`を設けることは許容する。つまり、**usersテーブル**および**UserRepository**は問題ない。
- RDMSにおいては、原則オプティマイザーを信用し、ヒント句の使用は控える。問題が生じたときのみヒント句の使用を検討する。
- TODO：レコードにNULLを認めるか否か、イベントをすべて記録するかどうか、レコードのUPDATEを禁止してINSERTとDELETEのみでデータベースを操作するかどうか、などは今後検討する。
---
## 条件分岐
- ネスト構造は、**早期return**などを用いて、極力避ける。
- 区分変数を用いた`switch`や`if`による分岐は、機能追加または変更の際に抜け漏れのリスクが低くない。そのため、デザインパターンでの実装を検討する。
---
## 計算量
- 時間計算量が劇的に削減できない限りは、複雑なアルゴリズムは控える。劇的に削減の基準はオーダー記法でのNの次数が下がる場合を指す。
- 時間計算量がオーダー記法で **O(10^8)（=約2秒）** を超える場合は、ディレードまたはバッチ処理断面情報での対応を検討する。
- 今後計算量を意識しないといけないと思われる処理は現状は以下の想定。
    - 友達機能を実装した場合のレコメンド機能。幅優先探索をしてプライオリティキューで順位付けするだけなので問題ない気がする。
    - 入力タブ入力補助のトライ木。大本命。
---
## 例外設計方針と実装
### 方針
1. **異常系の例外スローとハンドリング**:
   - 業務ロジックやシステムエラーなどの異常系は例外をスローしてハンドリングする。

2. **基底例外クラス `BaseException` の設置**:
   - アプリケーション全体で共通して使用できる基底例外クラスを設ける。
   - 基底例外クラスには、エラーコード (`errorCode`) を保持するフィールドを用意し、エラーの識別と管理を一元化する。

3. **層ごとの例外クラスの継承設計**:
   - ヘキサゴナルアーキテクチャの各層（`domain`, `application`, `adapter`, `infrastructure`）で基底例外を継承し、独自の例外クラスを設ける。
   - 層ごとに異なるエラーメッセージやハンドリングを可能にする。

4. **例外ハンドリングの集中管理**:
   - Spring Bootの`@RestControllerAdvice`を用いてグローバル例外ハンドラーを実装し、各層の例外に応じた適切なレスポンスを返す。

### 実装例

#### 1. 基底例外クラス: `BaseException`
基底例外クラスはエラーコードを保持し、共通の例外処理を提供する。

```java
public abstract class BaseException extends RuntimeException {
    private final String errorCode;

    protected BaseException(String message, String errorCode) {
        super(message);
        this.errorCode = errorCode;
    }

    public String getErrorCode() {
        return errorCode;
    }
}
```
#### 2. 層ごとの例外クラス

#### `domain`層例外
**ドメイン層**では、ビジネスルールやドメインモデルの整合性違反を表現する例外を設ける。

```java
public class DomainRuleViolationException extends BaseException {
    public DomainRuleViolationException(String message, String errorCode) {
        super(message, errorCode);
    }
}
```

#### `application`層例外
**アプリケーション層**では、ユースケースや業務ルール違反を表現する例外を設ける。
``` java
public class BusinessRuleViolationException extends BaseException {
    public BusinessRuleViolationException(String message, String errorCode) {
        super(message, errorCode);
    }
}
```
#### 3. エラーコードの管理
エラーコードは一元管理することで、一貫性と再利用性を確保する。
``` java
public class ErrorCodes {
    // Domain層エラーコード
    public static final String INVALID_USER_ID = "DOM_001";

    // Application層エラーコード
    public static final String DUPLICATE_USER = "APP_001";

    // Infrastructure層エラーコード
    public static final String DATABASE_ERROR = "INFRA_001";
}
```
#### 4. グローバル例外ハンドラー
各層の例外をキャッチし、適切なレスポンスを返す。
ハンドラークラスは、`/adapter/inbound/handler`に配置する。
``` java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(DomainRuleViolationException.class)
    public ResponseEntity<ErrorResponse> handleDomainException(DomainRuleViolationException ex) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                             .body(new ErrorResponse(ex.getErrorCode(), ex.getMessage()));
    }

    @ExceptionHandler(BusinessRuleViolationException.class)
    public ResponseEntity<ErrorResponse> handleApplicationException(BusinessRuleViolationException ex) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                             .body(new ErrorResponse(ex.getErrorCode(), ex.getMessage()));
    }

    @ExceptionHandler(InfrastructureException.class)
    public ResponseEntity<ErrorResponse> handleInfrastructureException(InfrastructureException ex) {
      // エンドユーザーには一般化されたエラーメッセージを表示
        log.error("Infrastructure error occurred: {}", ex.getMessage(), ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                             .body(new ErrorResponse(ex.getErrorCode(), "An unexpected error occurred."));
    }
}

```
#### 5. エラーレスポンスDTO
レスポンスとしてクライアントに返すエラーメッセージを定義する。
``` java
public record ErrorResponse(String errorCode, String message) {}
```
---
## ロギング設計

### ロギングフレームワークの選定
本プロジェクトでは、ロギングのAPIとして**SLF4J (Simple Logging Facade for Java)**を使用し、具体的なロギングの実装として**Logback**を採用する。

#### SLF4Jの役割
- **統一されたロギングAPI**: SLF4Jは、ロギングのための統一されたAPIを提供します。これにより、アプリケーションコードは特定のロギング実装に依存せずにロギングを行うことができる。
- **柔軟性**: SLF4Jを使用することで、ロギングの実装をLogbackから他の実装（例：Log4j、java.util.logging）に変更する際も、アプリケーションコードを変更する必要がない。

#### Logbackの役割
- **高性能なロギング実装**: Logbackは、SLF4Jのための高性能なロギング実装である。設定が柔軟で、ファイルローテーションやログのフィルタリングなどの機能を提供する。
- **設定の柔軟性**: LogbackはXMLやGroovyで設定を行うことができ、ログの出力先やフォーマットを簡単に変更できる。
- **導入方法**: Logbackの設定ファイルを`src/main/resources`ディレクトリに用意し、プロジェクトにLogbackの依存関係を追加することで、SLF4Jは自動的にLogbackを使用するようになる。
    - **依存関係の追加例**:
        - **Mavenの場合**:
            ```xml
            <dependency>
                <groupId>ch.qos.logback</groupId>
                <artifactId>logback-classic</artifactId>
                <version>1.2.11</version>
            </dependency>
             ```

### ロギングの設定例
以下は、Logbackの設定ファイルの例となる。`src/main/resources/logback.xml`に配置する。

```xml
<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/app.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/app.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="FILE" />
    </root>
</configuration>
```

### ロギングの使用例
各クラスでSLF4Jの`Logger`を使用してログを記録する。

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SomeService {
    // ログメッセージに出力クラスを表示するために引数に自身のクラスを指定
    private static final Logger logger = LoggerFactory.getLogger(SomeService.class);

    public void someMethod() {
        // ログレベルがINFO以下の場合はログファイルおよびコンソールに出力
        logger.info("This is an info message");
        // ログレベルがDEBUG以下の場合はログファイルおよびコンソールに出力
        logger.debug("This is a debug message");
        try {
            // Some code that might throw an exception
        } catch (Exception e) {
            logger.error("An error occurred", e);
        }
    }
}
```
### 実装方針
通常のログ設計では、logback.xmlで設定を行い、アプリケーションコードではSLF4JのLoggerを使用してログを記録するだけで十分。つまり、infrastructure層に特別なコードを追加する必要はない。
ただし、今後以下のような要件が出てきた場合は`infrastructure`での実装を検討する。
- カスタムアペンダー:特定の要件に応じて、Logbackの標準アペンダーでは対応できない場合
- カスタムフィルター:ログメッセージをフィルタリングするため
- ログの初期化コード:特定の初期化処理が必要な場合、アプリケーションの起動時にログの設定をプログラムで変更
---

## Webクライアント
`WebClient`を利用する。  
### 選定理由
- Spring WebFluxの一部で、非ブロッキングI/Oを活用しており、リソース効率が良く、高スループットを実現
- 非同期だけではなく、`block()`メソッドによって同期的に使用することも可能であり、拡張性に優れている
- タイムアウトやリトライなどの設定が容易
#### 補足 同期と非同期
- **同期**：処理が順番に実行され、1つの処理が完了するまで次の処理が待機（ブロック）する。
  ```java
  String response = webClient.get()
    .uri("/endpoint")
    .retrieve()
    .bodyToMono(String.class)
    .block(); //  同期的に処理を開始
  ```

- **非同期**：リクエストを送信すると、その結果を待たずに次の処理を実行する。結果は後から通知（コールバックやリアクティブ型）を受けとる。スレッドを待機させないため、大量のリクエスト処理や高スループットのシステムで有効。

  ```java
  WebClient webClient = WebClient.create();
  webClient.get()
          .uri("https://api.example.com/endpoint")
          .retrieve()
          .bodyToMono(String.class)
          .doOnNext(response -> System.out.println("Received: " + response)) // レスポンス準備後に実行
          .subscribe(); // 非同期的に処理を開始
  System.out.println("Request sent!"); // この行はリクエストを送信後すぐに実行される
  ```
**同期と非同期の選択基準**
- 同期を選択する場合：処理がユーザー応答に直結し、すぐに結果が必要な場合。
- 非同期を選択する場合：処理がエンドユーザー応答に直接関係しない場合（例：通知送信、ログ保存）。

### 実装方針
- インタフェースを`application/port/outbound`に用意し、その実装クラスを`adapter/inbound`に用意する。
- エンドポイントごとにメソッドを設けるのではなく、**ジェネリクス型推論**を利用することで、メソッドを抽象化する。
  ```java
  // 引数のClass<T> responseTypeに基づいて、メソッド全体でTの型が決定される
  public <T> Mono<T> fetchData(String endpoint, Class<T> responseType) {
    return webClient.get()
            .uri(endpoint)
            .retrieve()
            // Spring WebFluxのbodyToMono(Class<T>)は、レスポンスボディを指定された型にデシリアライズする
            // マッピング処理は、内部的にJackson（デフォルトのJSONライブラリ）が行う
            .bodyToMono(responseType);
  }
  ```
- 単体クラスではなく、`List`で結果を受け取ることもできる。
  ```java
  public <T> Mono<List<T>> fetchData(String endpoint, Class<T> responseType) {
    // 略
  }
  ```
### 高度な実装
外部WebAPIを利用する際、レスポンスとドメインエンティティが一致しない場合は、`adapter`層に**レスポンスを受け取るためのクラス**と**マッピング用のインタフェースおよびクラス**を設け、ドメインエンティティの純粋性を確保する。  
例えば、`Foo`と`Bar`という項目のみをドメインエンティティのフィールドに持ちたく、`Hoge`項目も併せて応答する外部WebAPIを利用する場合は、**当該3項目をフィールドの有するレスポンス用クラス**と**当該2項目のみをフィールドに有するドメインエンティティクラス**を用意する。

  ***実装例***   
  **ドメインエンティティ**：`position`フィールドのみ
  ```java
  public class IssDomainObject {
    private final String position;

    public IssDomainObject(String position) {
        this.position = position;
    }

    public String getPosition() {
        return position;
    }
  }
  ```
  **外部APIレスポンスDTO**：`position`に加えて、`message`フィールドも含まれる。`message`フィールドはドメインエンティティには不要。
  ```java
  public class IssResponse {
    private String message;
    private String issPosition;

    // getter
    public String getIssPosition() {
        return issPosition;
    }
  }
  ```
  **レスポンス変換用インタフェース**：汎用性を高めるためにインタフェースを用意
  ```java
  public interface ResponseMapper<T, R> {
    R mapResponse(T response);
    Class<T> getResponseType(); // 対応するレスポンスDTOの型を取得
    Class<R> getDomainType();   // 対応するドメインの型を取得
  }
  ```
  **レスポンス変換ロジック（具体的なMapper）**：上記インタフェースを実装
  ```java
  @Component
  public class IssResponseMapper implements ResponseMapper<IssResponse, IssDomainObject> {
      @Override
      public IssDomainObject mapResponse(IssResponse response) {
          return new IssDomainObject(response.getIssPosition());
      }

      @Override
      public Class<IssResponse> getResponseType() {
          return IssResponse.class; // このマッパーが対応するレスポンスの型
      }

      @Override
      public Class<IssDomainObject> getDomainType() {
          return IssDomainObject.class; // このマッパーが対応するドメインの型
      }
  }
  ```
  **WebClient**：上記変換ロジックを利用して、`adapter`層でレスポンスをドメインオブジェクトにマッピング。
  ```java
  private final List<ResponseMapper<?, ?>> mappers;

  @Override
  public <T, R> Mono<R> fetchData(String endpoint, Class<R> domainType) {
        ResponseMapper<T, R> mapper = findMapper(domainType);

      return webClient.get()
              .uri(endpoint)
              .retrieve()
              .bodyToMono((Class<T>)mapper.getResponseType()) // 対応するレスポンス型を取得してリクエスト
              .map(mapper::mapResponse); // ドメインオブジェクトに変換
  }

  @SuppressWarnings("unchecked")
  private <T, R> ResponseMapper<T, R> findMapper(Class<R> domainType) {
      return (ResponseMapper<T, R>) mappers.stream()
              .filter(mapper -> isValidMapper(mapper, domainType))
              .findFirst()
              .orElseThrow(() -> new IllegalArgumentException(
                      "No mapper found for domainType: " + domainType.getName()));
  }

  private boolean isValidMapper(ResponseMapper<?, ?> mapper, Class<?> domainType) {
      // マッパーが対応するレスポンス型を検証
      return mapper.getResponseType().equals(domainType);
  }
  ```
  なお、`application`層にレスポンス用クラスを設けることで、表面上は依存性を内側に向けながらの対応が可能だが、`application`層に外部WebAPIの仕様が持ち込まれる（=結局外側に依存）するため、採用しない。外部WebAPIへの対応はすべて`adapter`層に閉じ込める。

### エラーハンドリング

本システムでは、信頼性と可用性を向上させるために、以下のエラーハンドリング方針とする。

1. **サーキットブレーカの導入**:
   - 外部サービスとの通信において、サーキットブレーカパターンを導入する。これにより、外部サービスが不安定な場合でも、システム全体の障害を防ぎ、迅速な復旧を可能にする。

2. **400系エラーのハンドリング**:
   - 400系エラーは、クライアント側のリクエストに問題があることを示すため、リトライを行わない。

3. **500系エラーのハンドリング**:
   - 500系エラーは、サーバー側の一時的な問題である可能性があるため、リトライする。
   - リトライの回数や間隔は、サーキットブレーカの設定に基づき、過負荷を避けるために慎重に設定する。

4. **フォールバック戦略**:
   - サーキットブレーカが開いた場合やリトライが失敗した場合には、フォールバック戦略を実施する。
   - フォールバック戦略には、キャッシュからのデータ提供や、ユーザーへの代替メッセージの表示などが含まれる。
---
### サーキットブレーカ
サーキットブレーカは、Resilience4jを使用して実装し、特定のエラーやタイムアウトが一定の閾値を超えた場合に回路を開く。  


---
# 試験
## 方針
- **時間がないからこそテストを書く**
  - テストを書くことで、後々のバグ修正や機能追加の際に時間を節約できる
  - 後からテストコードを書く方が、テスト対象とほぼ同時にテストコードを書くよりも遥かに難しい
  - コードを書いたらすぐにテストも書くことで、品質を保ちながら開発を進める。

## 具体的な記述
- テストメソッド名は日本語にしない
  - CIツールとの連携を意識し、英語で記述する。
- 最終的にはE2Eまでを目指したい。
- 単体、結合、システム試験の割合はピラミッド型になるようにする。
- 複合性能試験も最終的にはやってみたい。

# リフレクション
- **闇魔術**なので使わない。が、どこかで学習したい。
    - カスタムバリデーションアノテーションでは使用するかもしれない
