# セキュリティ
## 認証・認可方式
本システムでは、以下の2種類の認証・認可方式を採用する。
1. **ログイン**：
   - **方式**: ユーザーIDとパスワードを使用する。
   - **目的**: 認証に成功した場合、JWT（JSON Web Token）を発行し、以降のリクエストで利用可能なトークンを提供する。

2. **ログイン以外**：
   - **方式**: リクエストヘッダーに含まれるJWTを使用する。
   - **目的**: 各リクエストでJWTを検証し、認証・認可済みの状態で処理を進める。

## 実現方法
認証・認可の実現には、**Spring Security**を使用する。  
また、システム全体の設計としてヘキサゴナルアーキテクチャを採用しているため、レイヤーで責務を分割する。この分割によって、認証・認可における拡張性を確保する。

### **1. アダプター層**
- **役割**：認証・認可のフローを制御
  - 認証エンドポイントの設定（例: `/api/auth/login`）。
  - Spring Security によるフィルタ（認証順序など）の設定。
  - 認証やトークン処理を抽象化するためのインタフェースを定義。依存性を逆転させるため。

### **2. インフラストラクチャ層**
- **役割**：具体的な認証・認可ロジックを管理
  - アダプター層で定義されたインタフェースの実装。
  - 認証・認可処理の詳細（例: ユーザー情報の照合、パスワードの検証、権限検証）。
  - JWTに関する、生成、検証、情報抽出などの具体的な操作。

## 運用例
### **ログイン認証**
- **対象エンドポイント**: `/api/auth/login`
- **処理内容**:
  1. アダプター層において、エンドポイントと認証プロバイダー（`LoginAuthenticationProvider`）を設定。
  2. インフラストラクチャ層において、ID/Passwordを検証。
  3. アダプター層において、JWTを発行（※実装はインフラストラクチャ層）。
  4. アダプター層において、JWTをクライアントに返却。

### **リクエスト認証・認可**
- **対象**: ログイン以外のエンドポイント（例: `/api/exams`）
- **処理内容**:
  1. アダプター層において、フィルタ（`JwtAuthenticationFilter`）でリクエストヘッダーからJWTを抽出。
  2. インフラストラクチャ層において、JWTの有効性を検証し、必要な情報（例: ユーザーID、権限）を抽出。
  3. アダプター層において、認証・認可情報を `SecurityContext` に設定し、後続のビジネスロジックを実行。

## 暗号化アルゴリズム
`BCryptPasswordEncoder`は長い間広く使われてきたが、セキュリティの観点から、最近ではより新しいアルゴリズムや実装が推奨される。特にArgon2などの新しいパスワードハッシュアルゴリズムが注目されている。  
そのため、本プロジェクトはパスワードエンコーダとして`Argon2PasswordEncoder`を使用する。
```java
@Configuration
public class PasswordEncoderConfig {
    @Bean
    PasswordEncoder passwordEncoder() {
        return Argon2PasswordEncoder.defaultsForSpringSecurity_v5_8();
    }
}
```