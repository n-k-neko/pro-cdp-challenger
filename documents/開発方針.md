## 概要
- バックエンドとフロントエンドは完全に分ける。バックエンドではテンプレートエンジンは用いずWebAPIのみを提供し、フロントエンドはWebAPIをコールする形とする。
    - フロントエンドの学習のため。VanillaJSとThymeleaf以外実装経験がなく、ReactまたはVueを触りたい。
- クリーンなアーキテクチャを志向する。
    - ヘキサゴナルアーキテクチャをベースにする。
- オブジェクトはデータの入れ物ではなく、機能を有する部品として設計する。
- アプリケーション開発についての学習が主目的であるため、サービスの質はあまり重要視せず、不要またはデメリットでしかない機能も検討する。
    - 例：試験の状態には遷移先の制限を設けるが一般的なサービスでは確実に邪魔な機能である。一例としては「計画中」から「合格」には直接は遷移させない制約を設ける。ユーザーは「計画中」から「学習中」に状態を変更するリクエストを送った後、「学習中」から「合格」に状態を変更するリクエストを送らなければならない。
- ドキュメント類については、成果物一覧を学びつつ、合間合間で作成する。

## アーキテクチャ
- クリーンなアーキテクチャを志向する。
- 最近読んでいる本でヘキサゴナルアーキテクチャが紹介されており、面白い（←TODO：今後書く？）と思ったのでベースに採用する。
    - ただし、まだ読書中かつ細部は書かれていないため手探り状態であり、間違っている可能性もアリ。
- ドメインごとにパッケージを切り、その下に **{adapter, application, domain, infrastructure}** を用意することも考えたが、以下の理由により採用しなかった。
    - ドメイン数が少なくなる見込み。そのため、アーキテクチャを先頭にしても各パッケージのファイルの数は多くはならない（はず）。
    - 小規模アプリケーションであればアーキテクチャを先頭にして、その下で適宜必要に応じてドメインでパッケージ分割したほうが開発が楽と感じる。

## クラス・レコード・オブジェクト
- オブジェクトは原則イミュータブルとする。
    - Setterは原則設けない。
- 上記をJavaの機能として実現するために**record**を積極的に用いる。ただし以下の場合などはクラスとする。
    - 継承、インタフェースの実装が必要
    - 不変としないフィールドが必要
- 値はクラスまたはレコードで表現する。コンストラクタで異常な値の代入を検知して例外を投げる。
- オブジェクトはデータの入れ物として用いるのではなく、オブジェクト自体に処理を行わせる。
- 継承は極力控える。インタフェースやフィールドオブジェクトで代替する。
- クラスへのLombokアノテーションの付与は許容する。O/Rマッパーについては後述。

## アプリケーション
- ビジネスロジックのフローの制御と外部との通信（例：DB）のみを行い、ビジネスロジックの主要な処理についてはドメイン層に任せる。

## ルール、ポリシー
- ポリシーはルールの集合とする。
- ユースケース（=ポート）の実装クラスの処理の中でif文などでチェックを行うのではなく、各ルールをそれぞれクラスで表現し、ポリシークラスで各ルールクラスとの関係をチェックする。
- ルールおよびポリシーは、ドメイン層とアプリケーション層でそれぞれ設ける。チェックする内容が違うため。
    - ドメイン層：純粋なドメイン個別固有の制約
    - アプリケーション層：外部制約

## リポジトリーとデータベース
- ドメインごとにHogeRepositoryという形にするのではなく、ドメイン内でも用途に応じてRepositoryを分割する。つまり、**UserRepository**などを作ってしまい、Repositoryが肥大化、責任が集中することを避ける。
    - ただし、汎用的な処理を**UserRepository**としてまとめることは許容する。
- RDMSにおいては、原則オプティマイザーを信用し、ヒント句の使用は控える。問題が生じたときのみヒント句の使用を検討する。
- O/Rマッパーを導入する場合は、ドメインのエンティティに付与するのではなく、専用のクラスを用意してドメインのエンティティクラスをマッピングする。つまり、ドメインのエンティティにはO/Rマッパーは持ち込まない。
- レコードにNULLを認めるか否か、イベントをすべて記録するかどうか、レコードのUPDATEを禁止してINSERTとDELETEのみでデータベースを操作するかどうか、などは今後検討する。

## 実装
### 条件分岐
- ネスト構造は極力避ける。早期returnなどで対応する。
- switchやifでの区分分岐は修正の際の抜け洩れが怖いので、デザインパターンでの実装を検討する。
### 計算量
- 時間計算量が劇的に削減できない限りは、複雑なアルゴリズムは控える。劇的に削減の基準はオーダー記法でのNの次数が下がる場合を指す。
    - 友達機能を実装した場合などに時間計算量を意識する可能性が出てくるかもしれない。「2ノード以内の友人の取得/学習している資格一覧を取得しレコメンド」など。幅優先探索をしてプライオリティキューで順位付けするだけなので問題ないのでは。
    - 入力補助を入れる場合はトライ木なので、これが本命？

## 例外
- 異常系は例外をスローしてハンドリングする。
- 例外ハンドリングは **@ControllerAdvice** を用いてグローバル例外ハンドラーを実装する。
- カスタム例外を作りすぎると保守が大変になるため、汎用的な例外と少しの例外だけを用意し、メッセージを細分化することで対応する。

## ロギング
- LF4JとLogbackを使ってログを記録する。
- ログレベルの設定と運用については今後検討する。
    - ファイル出力やログ運用（S3）など

## 試験
- 最終的にはE2Eまでを目指したい。
- 単体、結合、システム試験の割合はピラミッド型になるようにする。
- 複合性能試験も最終的にはやってみたい。

## リフレクション
- **闇魔術**なので使わない。が、どこかで学習したい。
    - カスタムバリデーションアノテーションでは使用するかもしれない
        - 必要そうな入力値を設ける

## クラウド
- AWSを使用する。
    - ECSでのアプリケーションの実行を予定している。EC2での運用は経験があるが、ECSは方法が定かではないので今後の学習機会でキャッチアップする。
    - DynamoDBもこの機会に学習したい。
    - CI/CDもこの機会に学習する。

## 生成AI
- GitHub Copliotは使用するが、コードをすべて自動生成するツールは使用しない。
    - 学習のため。